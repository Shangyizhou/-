## 题目

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？



**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```



**限制：**

`0 <= 数组长度 <= 10^5`

## 思路

**确定dp数组**

买股票，每一天都有两种情况，持有和不持有
设置`dp[i][0] `为第i天持有股票的最大利润
设置`dp[i][1] `为第i天不持有股票的最大利润

**第i天持有股票有两种情况**

dp`[i][0]`分为两种情况，第i天才持有和第i天以前就持有

- 第i天之前就持有：`dp[i][0] = dp[i - 1][0]`
- 第i天才持有：    `dp[i][0]= -prices[i]`

**第i天不持有股票有两种情况**

dp`[i][1]`分为两种情况，第i天才不持有和第i天以前就不持有

- 第i天之前就持有：`dp[i][1] = dp[i - 1][1]`
- 第i天才持有：    `dp[i][1]= dp[i - 1][0] + prices[i]`

综合可得

    dp[i][0] = max(dp[i - 1][0], -prices[i]);
    dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);

**dp数组初始化**

第一天

`dp[i][0]`为持有情况，他只可能在这时刚持有，所以`dp[i][0] = - prices[i]`

`dp[i][1]`为不持有情况，他今天才买，不持有只可能为0，所以`dp[i][1] = 0`

**循环遍历**

我们返回为了方便与prices的数组顺序对应，也从0开始，最后返回`dp[prices.size() - 1][1]`

## 源代码

```C
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 每一天都有两种情况，持有和不持有
        // 设置dp[i][0] 为第i天持有股票的最大利润
        // 设置dp[i][1] 为第i天不持有股票的最大利润

        // dp[i][0]分为两种情况，第i天才持有和第i天以前就持有
        // 第i天之前就持有：dp[i][0] = dp[i - 1][0]
        // 第i天才持有：    dp[i][0] = -prices[i]

        // dp[i][1]分为两种情况，第i天卖出和第i天以前就卖出
        // 第i天之前就卖出：dp[i][1] = dp[i - 1][1]
        // 第i天才卖出：    dp[i][1] = dp[i - 1][0] + prices[i](记住，卖出前持有的利润是持有时的利润)
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size() + 1, vector<int>(2, 0));
        // 初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
        
    }
};
```

